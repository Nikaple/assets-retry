{"version":3,"file":"assets-retry.umd.js","sources":["../src/util.ts","../src/url.ts","../src/constants.ts","../src/retry-async.ts","../src/collector.ts","../src/retry-sync.ts","../src/retry-css.ts","../src/assets-retry.ts"],"sourcesContent":["import { scriptTag, linkTag, doc, retryIdentifier, ScriptElementCtor, LinkElementCtor, ImageElementCtor, ElementCtor } from './constants'\n\nexport const identity = function<T>(x: T): T {\n    return x\n}\nexport const noop = () => {\n    /* noop */\n}\n\nexport const hasOwn = Object.prototype.hasOwnProperty\n/**\n * safely calls a function\n *\n * @template T this\n * @template R ReturnType<func>\n * @param {(this: T, ...callbackArgs: any[]) => R} func\n * @param {T} thisArg\n * @param {*} args\n * @returns {R}\n */\nexport const safeCall = function<T, R>(\n    func: (this: T, ...callbackArgs: any[]) => R,\n    thisArg: T,\n    args: any\n): R {\n    // eslint-disable-next-line\n    if (typeof func !== 'function') {\n        return null as any\n    }\n    return func.call(thisArg, args)\n}\n\n/**\n * replace a substring with new one\n *\n * @param {string} current current string\n * @param {string} oldStr substring to replace\n * @param {string} newStr new string\n * @returns\n */\nexport const stringReplace = function(current: string, oldStr: string, newStr: string) {\n    const idx = current.indexOf(oldStr)\n    if (idx === -1) {\n        return current\n    }\n    return current.substring(0, idx) + newStr + current.substring(idx + oldStr.length)\n}\n\n/**\n * convert a camelCase string to a dash-separated string.\n *\n * @param {string} str\n * @returns\n */\nexport const toSlug = function(str: string) {\n    return str.replace(/([a-z])([A-Z])/g, (_, $1, $2) => `${$1}-${$2.toLowerCase()}`)\n}\n\n/**\n * transform an array-like object to array\n *\n * @template T\n * @param {ArrayLike<T>} arrayLike\n * @returns {T[]}\n */\nexport const arrayFrom = function<T>(arrayLike: ArrayLike<T>): T[] {\n    return [].slice.call(arrayLike)\n}\n/**\n * collect all property names from current object to its ancestor\n *\n * @param {any} obj\n * @returns\n */\nexport const collectPropertyNames = function(obj: any) {\n    const getProto = Object.getPrototypeOf\n        ? Object.getPrototypeOf\n        : function(x: any) {\n              return x.__proto__\n          }\n    let keys = Object.keys(obj)\n    while (getProto(obj)) {\n        keys = keys.concat(Object.keys(getProto(obj)))\n        obj = getProto(obj)\n    }\n    return keys.filter(key => key !== 'constructor')\n}\n\n/**\n * @example\n * isFunctionProperty(HTMLScriptElement.prototype, 'src); // false\n * isFunctionProperty(HTMLScriptElement.prototype, 'getAttribute'); // true\n * @param {any} proto\n * @param {string} key\n * @returns\n */\nexport const isFunctionProperty = function(proto: any, key: string) {\n    try {\n        return typeof proto[key] === 'function'\n    } catch (e) {\n        // TypeError: Illegal invocation\n        // when evaluating properties like\n        // HTMLScriptElement.prototype.src\n        return false\n    }\n}\n\n/**\n * on some browsers, calling `document.write` when\n * `document.readyState` is `loading` will clear the whole\n * page, which is not what we wanted.\n *\n * @returns\n */\nexport const supportDocumentWrite = () => {\n    return !/Edge|MSIE|rv:/i.test(navigator.userAgent)\n}\n\n/**\n * loads a new script element by previous failed script element\n *\n * @param {HTMLScriptElement} $script previous script element\n * @param {string} newSrc new url to try\n */\nexport const loadNextScript = function(\n    $script: HTMLScriptElement,\n    newSrc: string,\n    onload: () => void = noop\n) {\n    // when dealing with failed script tags in html,\n    // use `document.write` to ensure the correctness\n    // of loading order\n    if (doc.readyState === 'loading' && supportDocumentWrite()) {\n        const retryId = randomString()\n        const newHtml = $script.outerHTML\n            // delete previous retry id\n            .replace(/data-retry-id=\"[^\"]+\"/, '')\n            .replace(/src=(?:\"[^\"]+\"|.+)([ >])/, `${retryIdentifier}=${retryId} src=\"${newSrc}\"$1`)\n        doc.write(newHtml)\n        const newScript = doc.querySelector(\n            `script[${retryIdentifier}=\"${retryId}\"]`\n        ) as HTMLScriptElement\n        if (newScript) {\n            newScript.onload = onload\n        }\n        return\n    }\n    const $newScript = doc.createElement(scriptTag)\n    // copy script properties except src:\n    // type, noModule, charset, async, defer,\n    // crossOrigin, text, referrerPolicy, event,\n    // htmlFor, integrity (chrome)\n    Object.keys(ScriptElementCtor.prototype).forEach(function(key: string) {\n        if (key !== 'src' && ($script as any)[key] && typeof ($script as any)[key] !== 'object') {\n            try {\n                ;($newScript as any)[key] = ($script as any)[key]\n            } catch (_) {\n                /* noop */\n            }\n        }\n    })\n    $newScript.src = newSrc\n    $newScript.onload = $script.onload\n    $newScript.onerror = $script.onerror\n    $newScript.setAttribute(retryIdentifier, randomString())\n    // webpack nonce for csp\n    const originalNonce = $script.getAttribute('nonce')\n    if (originalNonce) {\n        $newScript.setAttribute('nonce', originalNonce)\n    }\n    doc.getElementsByTagName('head')[0].appendChild($newScript)\n}\n\n/**\n * get rules from styleSheet\n *\n * @param {CSSStyleSheet} styleSheet\n * @returns\n */\nexport const getCssRules = function(styleSheet: CSSStyleSheet) {\n    try {\n        return styleSheet.rules\n    } catch (_) {\n        try {\n            return styleSheet.cssRules\n        } catch (_) {\n            return null\n        }\n    }\n}\n/**\n * test if current browser support CSSRuleList\n *\n * @param {CSSStyleSheet} styleSheet\n * @returns\n */\nexport const supportRules = function(styleSheet: CSSStyleSheet) {\n    const rules = getCssRules(styleSheet)\n    return !!rules\n}\n\n/**\n * loads a new link element by previous failed link element\n *\n * @param {HTMLLinkElement} $link previous link element\n * @param {string} newHref new url to try\n */\nexport const loadNextLink = function($link: HTMLLinkElement, newHref: string, onload: () => void) {\n    const $newLink = doc.createElement(linkTag)\n    // copy link properties except href:\n    // disabled, href, crossOrigin, rel, relList, media, hreflang,\n    // type, as, referrerPolicy, sizes, imageSrcset, imageSizes,\n    // charset, rev, target, sheet, integrity, import (chrome)\n    Object.keys(LinkElementCtor.prototype).forEach(function(key: string) {\n        if (key !== 'href' && ($link as any)[key] && typeof ($link as any)[key] !== 'object') {\n            try {\n                ;($newLink as any)[key] = ($link as any)[key]\n            } catch (_) {\n                /* noop */\n            }\n        }\n    })\n    $newLink.href = newHref\n    $newLink.onload = onload\n    $newLink.setAttribute(retryIdentifier, randomString())\n    doc.getElementsByTagName('head')[0].appendChild($newLink)\n}\n\nexport const hashTarget = function(element: EventTarget | null) {\n    if (!element) {\n        return 'null'\n    }\n    if (!(element instanceof ElementCtor)) {\n        return 'not_supported'\n    }\n    const nodeName = element.nodeName\n    const src = (element as any).src\n    const href = (element as any).href\n    const dataRetryId = element.getAttribute(retryIdentifier)\n    return [nodeName, src, href, dataRetryId].join(';')\n}\n\nexport const randomString = () =>\n    Math.random()\n        .toString(36)\n        .slice(2)\n\n/**\n * 获取 HTML 标签中包含的 URL 信息\n * @param target\n */\nexport const getTargetUrl = function(target: EventTarget | null) {\n    if (target instanceof ScriptElementCtor || target instanceof ImageElementCtor) {\n        return target.src\n    }\n    if (target instanceof LinkElementCtor) {\n        return target.href\n    }\n    return null\n}\n","import { retryCollector, RetryStatistics } from './collector'\nimport { retryTimesProp, failedProp, succeededProp } from './constants'\n\nexport type Domain = string[] | { [x: string]: string }\nexport interface DomainMap {\n    [x: string]: string\n}\n\n/**\n * generate the domain map from user\n * @example\n * generateDomainMap(['a.cdn', 'b.cdn', 'c.cdn']) // {'a.cdn': 'b.cdn', 'b.cdn': 'c.cdn', 'c.cdn': 'a.cdn'}\n *\n * @param {Domain} domains\n * @returns {DomainMap}\n */\nexport const prepareDomainMap = function(domains: Domain): DomainMap {\n    // array\n    if (Array.isArray(domains)) {\n        return domains.reduce(function(domainMap, domain, idx, array) {\n            domainMap[domain] = array[(idx + 1) % array.length]\n            return domainMap\n        }, {} as DomainMap)\n    }\n    // object\n    return domains\n}\n\n/**\n * get path from src\n * @example\n * getUrlPath('https://a.cdn/js/1.js', 'a.cdn'); // '/js/1.js'\n * getUrlPath('https://a.cdn/namespace/js/1.js', 'a.cdn/namespace'); // '/js/1.js'\n * @param {string} src script src\n * @param {string} currentDomain domain name\n * @returns {string}\n */\nexport const getUrlPath = function(src: string, currentDomain: string) {\n    return src.substr(src.indexOf(currentDomain) + currentDomain.length, src.length)\n}\n\n/**\n * find out the domain of current loading script\n *\n * @param {string} src\n * @param {{ [x: string]: string }} domainMap\n * @returns\n */\nexport const getCurrentDomain = function(src: string, domainMap: DomainMap) {\n    return (\n        Object.keys(domainMap)\n            .filter(function(domain) {\n                return src.indexOf(domain) > -1\n            })\n            // sort by length (relevance)\n            .sort((prev, next) => next.length - prev.length)[0]\n    )\n}\n\n/**\n * extract domain from url, and get the\n * corresponding statistic collector\n * @param {string} url\n * @returns\n */\nexport const extractInfoFromUrl = function(\n    url: string,\n    domainMap: DomainMap\n): [string?, RetryStatistics?] {\n    const [srcPath, currentDomain] = splitUrl(url, domainMap)\n    if (!srcPath) {\n        return []\n    }\n    retryCollector[srcPath] = retryCollector[srcPath] || {\n        [retryTimesProp]: 0,\n        [failedProp]: [],\n        [succeededProp]: []\n    }\n    return [currentDomain, retryCollector[srcPath]]\n}\n\nexport const splitUrl = function(url: string, domainMap: DomainMap): [string, string] {\n    const currentDomain = getCurrentDomain(url, domainMap)\n    if (!currentDomain) {\n        return ['', '']\n    }\n    const srcPath = getUrlPath(url, currentDomain)\n    return [srcPath, currentDomain]\n}\n","export const retryTimesProp = 'retryTimes'\nexport const succeededProp = 'succeeded'\nexport const failedProp = 'failed'\nexport const maxRetryCountProp = 'maxRetryCount'\nexport const onRetryProp = 'onRetry'\nexport const onSuccessProp = 'onSuccess'\nexport const onFailProp = 'onFail'\nexport const domainProp = 'domain'\nexport const innerScriptProp = '_assetsRetryScript'\nexport const innerOnloadProp = '_assetsRetryOnload'\nexport const innerOnerrorProp = '_assetsRetryOnerror'\nexport const scriptTag = 'script'\nexport const linkTag = 'link'\nexport const hookedIdentifier = 'data-assets-retry-hooked'\nexport const retryIdentifier = 'data-retry-id'\nexport const win = window\nexport const doc = window.document\nexport const ElementCtor = win.HTMLElement\nexport const ScriptElementCtor = win.HTMLScriptElement\nexport const StyleElementCtor = win.HTMLStyleElement\nexport const LinkElementCtor = win.HTMLLinkElement\nexport const ImageElementCtor = win.HTMLImageElement","import {\n    collectPropertyNames,\n    stringReplace,\n    isFunctionProperty,\n    loadNextScript,\n    safeCall,\n    hasOwn,\n    noop\n} from './util'\n\nimport {\n    retryTimesProp,\n    succeededProp,\n    failedProp,\n    maxRetryCountProp,\n    onRetryProp,\n    domainProp,\n    innerScriptProp,\n    innerOnloadProp,\n    innerOnerrorProp,\n    scriptTag,\n    hookedIdentifier,\n    doc,\n    ScriptElementCtor,\n} from './constants'\nimport { retryCollector } from './collector'\nimport { prepareDomainMap, extractInfoFromUrl } from './url'\nimport { InnerAssetsRetryOptions } from './assets-retry'\n\nexport interface HookedScript {\n    [innerScriptProp]: HTMLScriptElement\n    [innerOnerrorProp]: (e: Partial<Event>) => void\n    [x: string]: any\n}\n\n// cache all properties of HTMLScriptElement.prototype\n// (including prototype properties) because it's big (length > 200)\n// otherwise it would be calculated every time when\n// a script request failed.\nlet scriptProperties: string[];\ntry {\n    scriptProperties = collectPropertyNames(ScriptElementCtor.prototype)\n} catch (_) { /* noop */ }\n\n/**\n * create the descriptor of hooked script object,\n * accessing any property on the hooked script object\n * will be delegated to the real HTMLScriptElement\n * except onload/onerror events\n *\n * @param {any} self hookedScript\n * @param {object} opts\n * @returns\n */\nconst getHookedScriptDescriptors = function(self: HookedScript, opts: InnerAssetsRetryOptions) {\n    const maxRetryCount = opts[maxRetryCountProp]\n    const domainMap = prepareDomainMap(opts[domainProp])\n    const onRetry = opts[onRetryProp]\n    return scriptProperties.reduce(function(descriptor, key) {\n        const isFn = isFunctionProperty(ScriptElementCtor.prototype, key)\n        // for function properties,\n        // do not assign getters/setters\n        if (isFn) {\n            descriptor[key] = {\n                value: function() {\n                    return (self[innerScriptProp] as any)[key].apply(\n                        self[innerScriptProp],\n                        arguments\n                    )\n                }\n            }\n        } else {\n            descriptor[key] = {\n                set: function(newVal) {\n                    if (key === 'onerror') {\n                        self[innerOnerrorProp] = newVal\n                        // hook error events,\n                        // forward the original onerror handler\n                        // to the next script element to load\n                        ;(self[innerScriptProp] as any).onerror = function(event: ErrorEvent) {\n                            event.stopPropagation && event.stopPropagation()\n                            const callOriginalOnError = () => safeCall(self[innerOnerrorProp], self[innerScriptProp], event)\n                            const src = self[innerScriptProp].src\n                            const [currentDomain, currentCollector] = extractInfoFromUrl(\n                                src,\n                                domainMap\n                            )\n                            if (!currentDomain || !currentCollector) {\n                                return callOriginalOnError()\n                            }\n                            const newSrc = stringReplace(\n                                src,\n                                currentDomain,\n                                domainMap[currentDomain]\n                            )\n                            const userModifiedSrc = onRetry(newSrc, src, currentCollector)\n                            // if onRetry returns null, do not retry this url\n                            if (userModifiedSrc === null) {\n                                return callOriginalOnError()\n                            }\n                            // eslint-disable-next-line\n                            if (typeof userModifiedSrc !== 'string') {\n                                throw new Error('a string should be returned in `onRetry` function')\n                            }\n                            if (currentCollector[retryTimesProp] <= maxRetryCount) {\n                                loadNextScript(self[innerScriptProp], userModifiedSrc)\n                            } else {\n                                callOriginalOnError()\n                            }\n                        }\n                        return\n                    }\n                    if (key === 'onload') {\n                        self[innerOnloadProp] = newVal\n                        self[innerScriptProp].onload = function(event: Event) {\n                            const src = self[innerScriptProp].src\n                            const [_, currentCollector] = extractInfoFromUrl(src, domainMap)\n                            if (currentCollector) {\n                                if (currentCollector[failedProp].indexOf(src) === -1) {\n                                    currentCollector[succeededProp].push(src)\n                                }\n                            }\n                            if (newVal && !newVal._called) {\n                                newVal._called = true\n                                newVal.call(self[innerScriptProp], event)\n                            }\n                        }\n                        return\n                    }\n                    ;(self[innerScriptProp] as any)[key] = newVal\n                },\n                get() {\n                    return (self[innerScriptProp] as any)[key]\n                }\n            }\n        }\n        return descriptor\n    }, {} as PropertyDescriptorMap)\n}\n\nconst createHookedScript = function(\n    $script: HTMLScriptElement,\n    opts: InnerAssetsRetryOptions\n): HookedScript {\n    $script.setAttribute(hookedIdentifier, 'true')\n    const $hookedScript: HookedScript = {\n        [innerScriptProp]: $script,\n        [innerOnerrorProp]: noop\n    }\n    const descriptors = getHookedScriptDescriptors($hookedScript, opts)\n    Object.defineProperties($hookedScript, descriptors)\n    return $hookedScript\n}\n\n/**\n * hook `document.createElement`\n * @param {InnerAssetsRetryOptions} opts\n */\nconst hookCreateElement = function(opts: InnerAssetsRetryOptions) {\n    const originalCreateElement = doc.createElement\n    ;(doc as any).createElement = function(name: string, options: any): any {\n        if (name === scriptTag) {\n            return createHookedScript((originalCreateElement as any).call(doc, scriptTag), opts)\n        }\n        return originalCreateElement.call(doc, name, options)\n    }\n    doc.createElement.toString = function() {\n        return 'function createElement() { [native code] }'\n    }\n}\n\n/**\n * create a hooked function which hooks every method of target.\n * if a method is hooked and its arguments contains the inner script tag\n * it will be replaced with the value of inner script tag\n *\n * @param {any} target hook target\n */\nconst hookPrototype = function(target: any) {\n    const functionKeys = Object.keys(target).filter(key => isFunctionProperty(target, key))\n    functionKeys.forEach(key => {\n        const originalFunc = target[key]\n        target[key] = function(): any {\n            const args = [].slice.call(arguments).map((item: any) => {\n                if (!item) return item;\n                return hasOwn.call(item, innerScriptProp) ? item[innerScriptProp] : item\n            })\n            return originalFunc.apply(this, args)\n        }\n        // keep original toString\n        if (/^\\w+$/.test(key)) {\n            target[key].toString = new Function(`return 'function ${key}() { [native code] }'`)\n        }\n    })\n}\n/**\n * init asynchronous retrying of script tags\n * @param {InnerAssetsRetryOptions} opts\n * @returns\n */\nexport default function initAsync(opts: InnerAssetsRetryOptions) {\n    hookCreateElement(opts)\n    // eslint-disable-next-line\n    if (typeof Node !== 'undefined') {\n        hookPrototype(Node.prototype)\n    }\n    // eslint-disable-next-line\n    if (typeof Element !== 'undefined') {\n        hookPrototype(Element.prototype)\n    }\n    return retryCollector\n}\n","/** @description data collector */\n\nimport { retryTimesProp, succeededProp, failedProp } from './constants'\n\nexport interface RetryCollector {\n    [x: string]: RetryStatistics\n}\n\nexport interface RetryStatistics {\n    [retryTimesProp]: number\n    [succeededProp]: string[]\n    [failedProp]: string[]\n}\n\n// statistic collector\nexport const retryCollector: RetryCollector = {}\n","import {\n    stringReplace,\n    loadNextScript,\n    loadNextLink,\n    hashTarget,\n    randomString,\n    arrayFrom,\n    getCssRules,\n    getTargetUrl\n} from './util'\nimport { InnerAssetsRetryOptions } from './assets-retry'\nimport { extractInfoFromUrl, splitUrl } from './url'\nimport {\n    retryTimesProp,\n    failedProp,\n    hookedIdentifier,\n    succeededProp,\n    doc,\n    retryIdentifier,\n    onRetryProp,\n    onSuccessProp,\n    onFailProp,\n    domainProp,\n    maxRetryCountProp,\n    ScriptElementCtor,\n    LinkElementCtor,\n    ImageElementCtor\n} from './constants'\n\nconst retryCache: { [x: string]: boolean } = {}\n\n/**\n * init synchronous retrying of assets,\n * this includes the retrying of\n * script, link and img tags\n *\n * @export\n * @param {InnerAssetsRetryOptions} opts\n */\nexport default function initSync(opts: InnerAssetsRetryOptions) {\n    const onRetry = opts[onRetryProp]\n    const onSuccess = opts[onSuccessProp]\n    const onFail = opts[onFailProp]\n    const domainMap = opts[domainProp]\n    /**\n     * capture error on window\n     * when js / css / image failed to load\n     * reload the target with new domain\n     *\n     * @param {ErrorEvent} event\n     * @returns\n     */\n    const errorHandler = function(event: Event) {\n        if (!event) {\n            return\n        }\n        const target = event.target || event.srcElement\n        const originalUrl = getTargetUrl(target)\n        if (!originalUrl) {\n            // not one of script / link / image element\n            return\n        }\n        const [currentDomain, currentCollector] = extractInfoFromUrl(originalUrl, domainMap)\n        if (!currentCollector || !currentDomain) {\n            return\n        }\n        currentCollector[retryTimesProp]++\n        currentCollector[failedProp].push(originalUrl)\n        const isFinalRetry = currentCollector[retryTimesProp] > opts[maxRetryCountProp]\n        if (isFinalRetry) {\n            const [srcPath] = splitUrl(originalUrl, domainMap)\n            onFail(srcPath)\n        }\n        if (!domainMap[currentDomain] || isFinalRetry) {\n            // can not find a domain to switch\n            // or failed too many times\n            return\n        }\n        const newDomain = domainMap[currentDomain]\n        const newUrl = stringReplace(originalUrl, currentDomain, newDomain)\n        const userModifiedUrl = onRetry(newUrl, originalUrl, currentCollector)\n        // if onRetry returns null, do not retry this url\n        if (userModifiedUrl === null) {\n            return\n        }\n        // eslint-disable-next-line\n        if (typeof userModifiedUrl !== 'string') {\n            throw new Error('a string should be returned in `onRetry` function')\n        }\n        // cache retried elements\n        const elementId = hashTarget(target)\n        if (retryCache[elementId]) {\n            return\n        }\n        retryCache[elementId] = true\n        const onloadCallback = () => {\n            currentCollector[succeededProp].push(userModifiedUrl)\n        }\n        if (\n            target instanceof ScriptElementCtor &&\n            !target.getAttribute(hookedIdentifier) &&\n            target.src\n        ) {\n            loadNextScript(target, userModifiedUrl, onloadCallback)\n            return\n        }\n        if (target instanceof LinkElementCtor && target.href) {\n            loadNextLink(target, userModifiedUrl, onloadCallback)\n            return\n        }\n        if (target instanceof ImageElementCtor && target.src) {\n            target.setAttribute(retryIdentifier, randomString())\n            target.src = userModifiedUrl\n            target.onload = onloadCallback\n        }\n    }\n\n    /**\n     * test is link element loaded in load event\n     *\n     * @param {Event} event\n     */\n    const loadHandler = function(event: Event) {\n        if (!event) {\n            return\n        }\n        const target = event.target || event.srcElement\n        const originalUrl = getTargetUrl(target)\n        if (!originalUrl) {\n            // not one of script / link / image element\n            return\n        }\n        if ((target as HTMLElement).getAttribute(retryIdentifier)) {\n            const [srcPath] = splitUrl(originalUrl, domainMap)\n            onSuccess(srcPath)\n        }\n        // only handle link element\n        if (!(target instanceof LinkElementCtor)) {\n            return\n        }\n        const supportStyleSheets = doc.styleSheets\n        // do not support styleSheets API\n        if (!supportStyleSheets) {\n            return\n        }\n        const styleSheets = arrayFrom(doc.styleSheets) as any[]\n        const targetStyleSheet = styleSheets.filter(styleSheet => {\n            return styleSheet.href === (target as any).href\n        })[0]\n        const rules = getCssRules(targetStyleSheet)\n        if (rules === null) {\n            return\n        }\n        if (rules.length === 0) {\n            errorHandler(event)\n        }\n    }\n\n    doc.addEventListener('error', errorHandler, true)\n    doc.addEventListener('load', loadHandler, true)\n}\n","import { arrayFrom, stringReplace, toSlug, supportRules, getCssRules } from './util'\nimport { doc, domainProp, onRetryProp, StyleElementCtor } from './constants'\nimport { getCurrentDomain, DomainMap } from './url'\nimport { InnerAssetsRetryOptions } from './assets-retry'\n\ntype UrlProperty = 'backgroundImage' | 'borderImage' | 'listStyleImage'\n// cache for <link rel=\"stylesheet\" />\nconst handledStylesheets: { [x: string]: boolean } = {}\n// cache for <style />\nconst handledStyleTags: HTMLStyleElement[] = []\n\nconst processRules = function(\n    name: UrlProperty,\n    rule: CSSStyleRule,\n    styleSheet: CSSStyleSheet,\n    styleRules: CSSStyleRule[],\n    opts: InnerAssetsRetryOptions\n) {\n    const domainMap = opts[domainProp]\n    const onRetry = opts[onRetryProp]\n    const targetRule = rule.style && rule.style[name]\n    if (!targetRule) {\n        return\n    }\n    // skip data-uri\n    if (/^url\\([\"']?data:/.test(targetRule)) {\n        return\n    }\n    const [_, originalUrl] = targetRule.match(/^url\\([\"']?(.+?)[\"']?\\)/) || []\n    if (!originalUrl) {\n        return\n    }\n    const currentDomain = getCurrentDomain(originalUrl, domainMap)\n    if (!currentDomain || !domainMap[currentDomain]) {\n        return\n    }\n    const urlList = Object.keys(domainMap)\n        .map(domain => {\n            const newUrl = stringReplace(originalUrl, currentDomain, domain)\n            const userModifiedUrl = onRetry(newUrl, originalUrl, null)\n            return `url(\"${userModifiedUrl}\")`\n        })\n        .join(',')\n    const cssText = rule.selectorText + `{ ${toSlug(name)}: ${urlList} !important; }`\n    try {\n        styleSheet.insertRule(cssText, styleRules.length)\n    } catch (_) {\n        styleSheet.insertRule(cssText, 0)\n    }\n}\n\nconst processStyleSheets = (styleSheets: CSSStyleSheet[], opts: InnerAssetsRetryOptions) => {\n    const urlProperties: UrlProperty[] = ['backgroundImage', 'borderImage', 'listStyleImage']\n    styleSheets.forEach((styleSheet: CSSStyleSheet) => {\n        const rules = getCssRules(styleSheet)\n        if (rules === null) {\n            return\n        }\n        const styleRules = arrayFrom(rules) as CSSStyleRule[]\n        styleRules.forEach(rule => {\n            urlProperties.forEach(cssProperty => {\n                processRules(cssProperty, rule, styleSheet, styleRules, opts)\n            })\n        })\n\n        if (styleSheet.href) {\n            handledStylesheets[styleSheet.href] = true\n        }\n        if (styleSheet.ownerNode instanceof StyleElementCtor) {\n            handledStyleTags.push(styleSheet.ownerNode)\n        }\n    })\n}\n\nconst getStyleSheetsToBeHandled = function(styleSheets: StyleSheetList, domainMap: DomainMap) {\n    return (arrayFrom(styleSheets) as CSSStyleSheet[]).filter(styleSheet => {\n        if (!supportRules(styleSheet)) {\n            return false\n        }\n        // <style /> tags\n        if (!styleSheet.href) {\n            const ownerNode = styleSheet.ownerNode\n            if (ownerNode instanceof StyleElementCtor && handledStyleTags.indexOf(ownerNode) > -1) {\n                return false\n            }\n            return true\n        }\n        if (handledStylesheets[styleSheet.href]) {\n            return false\n        }\n        const currentDomain = getCurrentDomain(styleSheet.href, domainMap)\n        return !!currentDomain\n    })\n}\n\nexport default function initCss(opts: InnerAssetsRetryOptions) {\n    // detect is support styleSheets\n    const supportStyleSheets = doc.styleSheets\n    const domainMap = opts[domainProp]\n    if (!supportStyleSheets) return false\n    setInterval(() => {\n        const newStyleSheets = getStyleSheetsToBeHandled(doc.styleSheets, domainMap)\n        if (newStyleSheets.length > 0) {\n            processStyleSheets(newStyleSheets, opts)\n        }\n    }, 250)\n}\n","import initAsync from './retry-async'\nimport initSync from './retry-sync'\nimport initCss from './retry-css'\nimport { RetryStatistics, retryCollector } from './collector'\nimport {\n    maxRetryCountProp,\n    onRetryProp,\n    onSuccessProp,\n    onFailProp,\n    domainProp,\n    win\n} from './constants'\nimport { Domain, DomainMap, prepareDomainMap } from './url'\nimport { identity, noop } from './util'\n\nexport type RetryFunction = (\n    currentUrl: string,\n    originalUrl: string,\n    retryCollector: null | RetryStatistics\n) => string | null\nexport type SuccessFunction = (currentPath: string) => void\nexport type FailFunction = (currentPath: string) => void\n\nexport interface AssetsRetryOptions {\n    [maxRetryCountProp]: number\n    [onRetryProp]?: RetryFunction\n    [onSuccessProp]?: SuccessFunction\n    [onFailProp]?: FailFunction\n    [domainProp]: Domain\n}\n\nexport interface InnerAssetsRetryOptions {\n    [maxRetryCountProp]: number\n    [onRetryProp]: RetryFunction\n    [onSuccessProp]: SuccessFunction\n    [onFailProp]: FailFunction\n    [domainProp]: DomainMap\n}\n\nexport default function init(opts: AssetsRetryOptions = {} as any) {\n    try {\n        // eslint-disable-next-line\n        if (typeof opts[domainProp] !== 'object') {\n            throw new Error('opts.domain cannot be non-object.')\n        }\n        const optionList = [maxRetryCountProp, onRetryProp, onSuccessProp, onFailProp, domainProp]\n        const invalidOptions = Object.keys(opts).filter(key => optionList.indexOf(key) === -1)\n        if (invalidOptions.length > 0) {\n            throw new Error('option name: ' + invalidOptions.join(', ') + ' is not valid.')\n        }\n        const innerOpts: InnerAssetsRetryOptions = {\n            [maxRetryCountProp]: opts[maxRetryCountProp] || 3,\n            [onRetryProp]: opts[onRetryProp] || identity,\n            [onSuccessProp]: opts[onSuccessProp] || noop,\n            [onFailProp]: opts[onFailProp] || noop,\n            [domainProp]: prepareDomainMap(opts[domainProp])\n        }\n        initAsync(innerOpts)\n        initSync(innerOpts)\n        if (__RETRY_IMAGE__) {\n            initCss(innerOpts)\n        }\n        return retryCollector\n    } catch (e) {\n        win.console && console.error('[assetsRetry] error captured', e)\n    }\n}\n"],"names":["identity","x","noop","isFunctionProperty","proto","key","e","prepareDomainMap","domains","Array","isArray","reduce","domainMap","domain","idx","array","length","getCurrentDomain","src","Object","keys","filter","indexOf","sort","prev","next","scriptProperties","retryTimesProp","succeededProp","failedProp","maxRetryCountProp","onRetryProp","onSuccessProp","onFailProp","domainProp","innerScriptProp","innerOnerrorProp","scriptTag","hookedIdentifier","retryIdentifier","win","window","doc","document","ElementCtor","HTMLElement","ScriptElementCtor","HTMLScriptElement","StyleElementCtor","HTMLStyleElement","LinkElementCtor","HTMLLinkElement","ImageElementCtor","HTMLImageElement","hasOwn","prototype","hasOwnProperty","stringReplace","current","oldStr","newStr","substring","arrayFrom","arrayLike","slice","call","loadNextScript","$script","newSrc","onload","readyState","test","navigator","userAgent","$newScript","createElement","forEach","_","onerror","setAttribute","randomString","originalNonce","getAttribute","getElementsByTagName","appendChild","retryId","newHtml","outerHTML","replace","write","newScript","querySelector","getCssRules","styleSheet","rules","cssRules","loadNextLink","$link","newHref","$newLink","href","hashTarget","element","nodeName","join","Math","random","toString","getTargetUrl","target","retryCollector","extractInfoFromUrl","url","_b","srcPath","currentDomain","_a","splitUrl","substr","obj","getProto","getPrototypeOf","__proto__","concat","collectPropertyNames","getHookedScriptDescriptors","self","opts","maxRetryCount","onRetry","descriptor","isFn","value","apply","arguments","set","newVal","event","stopPropagation","callOriginalOnError","func","thisArg","args","currentCollector","userModifiedSrc","Error","push","_called","get","hookCreateElement","originalCreateElement","name","options","$hookedScript","descriptors","defineProperties","createHookedScript","hookPrototype","originalFunc","map","item","this","Function","retryCache","initSync","errorHandler","srcElement","originalUrl","isFinalRetry","onFail","newDomain","newUrl","userModifiedUrl","elementId","onloadCallback","onSuccess","addEventListener","styleSheets","targetStyleSheet","processRules","rule","styleRules","targetRule","style","urlList","cssText","selectorText","$1","$2","toLowerCase","insertRule","handledStylesheets","handledStyleTags","processStyleSheets","urlProperties","cssProperty","ownerNode","getStyleSheetsToBeHandled","optionList_1","invalidOptions","innerOpts","Node","Element","supportStyleSheets","setInterval","newStyleSheets","initCss","console","error"],"mappings":"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"}