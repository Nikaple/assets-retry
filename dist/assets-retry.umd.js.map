{"version":3,"file":"assets-retry.umd.js","sources":["../src/util.ts","../src/url.ts","../src/constants.ts","../src/retry-async.ts","../src/collector.ts","../src/retry-sync.ts","../src/weak-set.ts","../src/retry-css.ts","../src/assets-retry.ts"],"sourcesContent":["import {\r\n    scriptTag,\r\n    linkTag,\r\n    doc,\r\n    retryIdentifier,\r\n    ScriptElementCtor,\r\n    LinkElementCtor,\r\n    ImageElementCtor,\r\n    ElementCtor\r\n} from './constants'\r\n\r\nexport const identity = function<T>(x: T): T {\r\n    return x\r\n}\r\nexport const noop = () => {\r\n    /* noop */\r\n}\r\n\r\nexport const hasOwn = Object.prototype.hasOwnProperty\r\n/**\r\n * safely calls a function\r\n *\r\n * @template T this\r\n * @template R ReturnType<func>\r\n * @param {(this: T, ...callbackArgs: any[]) => R} func\r\n * @param {T} thisArg\r\n * @param {*} args\r\n * @returns {R}\r\n */\r\nexport const safeCall = function<T, R>(\r\n    func: (this: T, ...callbackArgs: any[]) => R,\r\n    thisArg: T,\r\n    args: any\r\n): R {\r\n    // eslint-disable-next-line\r\n    if (typeof func !== 'function') {\r\n        return null as any\r\n    }\r\n    return func.call(thisArg, args)\r\n}\r\n\r\n/**\r\n * replace a substring with new one\r\n *\r\n * @param {string} current current string\r\n * @param {string} oldStr substring to replace\r\n * @param {string} newStr new string\r\n * @returns\r\n */\r\nexport const stringReplace = function(current: string, oldStr: string, newStr: string) {\r\n    const idx = current.indexOf(oldStr)\r\n    if (idx === -1) {\r\n        return current\r\n    }\r\n    return current.substring(0, idx) + newStr + current.substring(idx + oldStr.length)\r\n}\r\n\r\n/**\r\n * remove duplicates from an array of strings\r\n */\r\nexport const unique = function(array: string[]) {\r\n    const map = {} as any\r\n    array.forEach(item => {\r\n        map[item] = true\r\n    })\r\n    return Object.keys(map)\r\n}\r\n\r\n/**\r\n * convert a camelCase string to a dash-separated string.\r\n *\r\n * @param {string} str\r\n * @returns\r\n */\r\nexport const toSlug = function(str: string) {\r\n    return str.replace(/([a-z])([A-Z])/g, (_, $1, $2) => `${$1}-${$2.toLowerCase()}`)\r\n}\r\n\r\n/**\r\n * transform an array-like object to array\r\n *\r\n * @template T\r\n * @param {ArrayLike<T>} arrayLike\r\n * @returns {T[]}\r\n */\r\nexport const arrayFrom = function<T>(arrayLike: Iterable<T> | ArrayLike<T>): T[] {\r\n    return [].slice.call(arrayLike)\r\n}\r\n/**\r\n * collect all property names from current object to its ancestor\r\n *\r\n * @param {any} obj\r\n * @returns\r\n */\r\nexport const collectPropertyNames = function(obj: any) {\r\n    const getProto = Object.getPrototypeOf\r\n        ? Object.getPrototypeOf\r\n        : function(x: any) {\r\n              return x.__proto__\r\n          }\r\n    let keys = Object.keys(obj)\r\n    while (getProto(obj)) {\r\n        keys = keys.concat(Object.keys(getProto(obj)))\r\n        obj = getProto(obj)\r\n    }\r\n    return keys.filter(key => key !== 'constructor')\r\n}\r\n\r\n/**\r\n * @example\r\n * isFunctionProperty(HTMLScriptElement.prototype, 'src); // false\r\n * isFunctionProperty(HTMLScriptElement.prototype, 'getAttribute'); // true\r\n * @param {any} proto\r\n * @param {string} key\r\n * @returns\r\n */\r\nexport const isFunctionProperty = function(proto: any, key: string) {\r\n    try {\r\n        return typeof proto[key] === 'function'\r\n    } catch (e) {\r\n        // TypeError: Illegal invocation\r\n        // when evaluating properties like\r\n        // HTMLScriptElement.prototype.src\r\n        return false\r\n    }\r\n}\r\n\r\n/**\r\n * on some browsers, calling `document.write` when\r\n * `document.readyState` is `loading` will clear the whole\r\n * page, which is not what we wanted.\r\n *\r\n * @returns\r\n */\r\nexport const supportDocumentWrite = () => {\r\n    return !/Edge|MSIE|rv:/i.test(navigator.userAgent)\r\n}\r\n\r\n/**\r\n * loads a new script element by previous failed script element\r\n *\r\n * @param {HTMLScriptElement} $script previous script element\r\n * @param {string} newSrc new url to try\r\n */\r\nexport const loadNextScript = function(\r\n    $script: HTMLScriptElement,\r\n    newSrc: string,\r\n    onload: () => void = noop,\r\n    isAsync = false\r\n) {\r\n    // when dealing with failed script tags in html,\r\n    // use `document.write` to ensure the correctness\r\n    // of loading order\r\n    const isAsyncScript = isAsync || $script.defer || $script.async\r\n    // only use document.write for non-async scripts,\r\n    // which includes script tag created by document.createElement\r\n    // or with `defer` or `async` attribute\r\n    if (doc.readyState === 'loading' && supportDocumentWrite() && !isAsyncScript) {\r\n        const retryId = randomString()\r\n        const newHtml = $script.outerHTML\r\n            // delete previous retry id\r\n            .replace(/data-retry-id=\"[^\"]+\"/, '')\r\n            .replace(/src=(?:\"[^\"]+\"|.+)([ >])/, `${retryIdentifier}=${retryId} src=\"${newSrc}\"$1`)\r\n        doc.write(newHtml)\r\n        const newScript = doc.querySelector(\r\n            `script[${retryIdentifier}=\"${retryId}\"]`\r\n        ) as HTMLScriptElement\r\n        if (newScript) {\r\n            newScript.onload = onload\r\n        }\r\n        return\r\n    }\r\n    const $newScript = doc.createElement(scriptTag)\r\n    // copy script properties except src:\r\n    // type, noModule, charset, async, defer,\r\n    // crossOrigin, text, referrerPolicy, event,\r\n    // htmlFor, integrity (chrome)\r\n    Object.keys(ScriptElementCtor.prototype).forEach(function(key: string) {\r\n        if (key !== 'src' && ($script as any)[key] && typeof ($script as any)[key] !== 'object') {\r\n            try {\r\n                ;($newScript as any)[key] = ($script as any)[key]\r\n            } catch (_) {\r\n                /* noop */\r\n            }\r\n        }\r\n    })\r\n    $newScript.src = newSrc\r\n    $newScript.onload = $script.onload\r\n    $newScript.onerror = $script.onerror\r\n    $newScript.setAttribute(retryIdentifier, randomString())\r\n    // webpack nonce for csp\r\n    const originalNonce = $script.getAttribute('nonce')\r\n    if (originalNonce) {\r\n        $newScript.setAttribute('nonce', originalNonce)\r\n    }\r\n    doc.getElementsByTagName('head')[0].appendChild($newScript)\r\n}\r\n\r\n/**\r\n * get rules from styleSheet\r\n *\r\n * @param {CSSStyleSheet} styleSheet\r\n * @returns\r\n */\r\nexport const getCssRules = function(styleSheet: CSSStyleSheet) {\r\n    try {\r\n        return styleSheet.rules\r\n    } catch (_) {\r\n        try {\r\n            return styleSheet.cssRules\r\n        } catch (_) {\r\n            return null\r\n        }\r\n    }\r\n}\r\n/**\r\n * test if current browser support CSSRuleList\r\n *\r\n * @param {CSSStyleSheet} styleSheet\r\n * @returns\r\n */\r\nexport const supportRules = function(styleSheet: CSSStyleSheet) {\r\n    const rules = getCssRules(styleSheet)\r\n    return !!rules\r\n}\r\n\r\n/**\r\n * loads a new link element by previous failed link element\r\n *\r\n * @param {HTMLLinkElement} $link previous link element\r\n * @param {string} newHref new url to try\r\n */\r\nexport const loadNextLink = function($link: HTMLLinkElement, newHref: string, onload?: () => void) {\r\n    const $newLink = doc.createElement(linkTag)\r\n    // copy link properties except href:\r\n    // disabled, href, crossOrigin, rel, relList, media, hreflang,\r\n    // type, as, referrerPolicy, sizes, imageSrcset, imageSizes,\r\n    // charset, rev, target, sheet, integrity, import (chrome)\r\n    Object.keys(LinkElementCtor.prototype).forEach(function(key: string) {\r\n        if (key !== 'href' && ($link as any)[key] && typeof ($link as any)[key] !== 'object') {\r\n            try {\r\n                ;($newLink as any)[key] = ($link as any)[key]\r\n            } catch (_) {\r\n                /* noop */\r\n            }\r\n        }\r\n    })\r\n    $newLink.href = newHref\r\n    $newLink.onload = onload || $link.onload\r\n    $newLink.onerror = $link.onerror\r\n    $newLink.setAttribute(retryIdentifier, randomString())\r\n    doc.getElementsByTagName('head')[0].appendChild($newLink)\r\n}\r\n\r\nexport const hashTarget = function(element: EventTarget | null) {\r\n    if (!element) {\r\n        return 'null'\r\n    }\r\n    if (!(element instanceof ElementCtor)) {\r\n        return 'not_supported'\r\n    }\r\n    const nodeName = element.nodeName\r\n    const src = (element as any).src\r\n    const href = (element as any).href\r\n    const dataRetryId = element.getAttribute(retryIdentifier)\r\n    return [nodeName, src, href, dataRetryId].join(';')\r\n}\r\n\r\nexport const randomString = () =>\r\n    Math.random()\r\n        .toString(36)\r\n        .slice(2)\r\n\r\n/**\r\n * 获取 HTML 标签中包含的 URL 信息\r\n * @param target\r\n */\r\nexport const getTargetUrl = function(target: EventTarget | null) {\r\n    if (target instanceof ScriptElementCtor || target instanceof ImageElementCtor) {\r\n        return target.src\r\n    }\r\n    if (target instanceof LinkElementCtor) {\r\n        return target.href\r\n    }\r\n    return ''\r\n}\r\n\r\nexport const isElementInCurrentContext = function (element: any) {\r\n    let parent: any = element\r\n    while (parent) {\r\n        parent = parent.parentNode\r\n        if (parent === doc) return true\r\n    }\r\n    return false;\r\n}","import { retryCollector, RetryStatistics } from './collector'\r\nimport { retryTimesProp, failedProp, succeededProp } from './constants'\r\n\r\nexport type Domain = string[] | { [x: string]: string }\r\nexport interface DomainMap {\r\n    [x: string]: string\r\n}\r\n\r\n/**\r\n * generate the domain map from user\r\n * @example\r\n * generateDomainMap(['a.cdn', 'b.cdn', 'c.cdn']) // {'a.cdn': 'b.cdn', 'b.cdn': 'c.cdn', 'c.cdn': 'a.cdn'}\r\n *\r\n * @param {Domain} domains\r\n * @returns {DomainMap}\r\n */\r\nexport const prepareDomainMap = function(domains: Domain): DomainMap {\r\n    // array\r\n    if (Array.isArray(domains)) {\r\n        return domains.reduce(function(domainMap, domain, idx, array) {\r\n            domainMap[domain] = array[(idx + 1) % array.length]\r\n            return domainMap\r\n        }, {} as DomainMap)\r\n    }\r\n    // object\r\n    return domains\r\n}\r\n\r\n/**\r\n * get path from src\r\n * @example\r\n * getUrlPath('https://a.cdn/js/1.js', 'a.cdn'); // '/js/1.js'\r\n * getUrlPath('https://a.cdn/namespace/js/1.js', 'a.cdn/namespace'); // '/js/1.js'\r\n * @param {string} src script src\r\n * @param {string} currentDomain domain name\r\n * @returns {string}\r\n */\r\nexport const getUrlPath = function(src: string, currentDomain: string) {\r\n    return src.substr(src.indexOf(currentDomain) + currentDomain.length, src.length)\r\n}\r\n\r\n/**\r\n * find out the domain of current loading script\r\n *\r\n * @param {string} src\r\n * @param {{ [x: string]: string }} domainMap\r\n * @returns\r\n */\r\nexport const getCurrentDomain = function(src: string, domainMap: DomainMap) {\r\n    return (\r\n        Object.keys(domainMap)\r\n            .filter(function(domain) {\r\n                return src.indexOf(domain) > -1\r\n            })\r\n            // sort by length (relevance)\r\n            .sort((prev, next) => next.length - prev.length)[0]\r\n    )\r\n}\r\n\r\n/**\r\n * extract domain from url, and get the\r\n * corresponding statistic collector\r\n * @param {string} url\r\n * @returns\r\n */\r\nexport const extractInfoFromUrl = function(\r\n    url: string,\r\n    domainMap: DomainMap\r\n): [string?, RetryStatistics?] {\r\n    const [srcPath, currentDomain] = splitUrl(url, domainMap)\r\n    if (!srcPath) {\r\n        return []\r\n    }\r\n    retryCollector[srcPath] = retryCollector[srcPath] || {\r\n        [retryTimesProp]: 0,\r\n        [failedProp]: [],\r\n        [succeededProp]: []\r\n    }\r\n    return [currentDomain, retryCollector[srcPath]]\r\n}\r\n\r\nexport const splitUrl = function(url: string, domainMap: DomainMap): [string, string] {\r\n    const currentDomain = getCurrentDomain(url, domainMap)\r\n    if (!currentDomain) {\r\n        return ['', '']\r\n    }\r\n    const srcPath = getUrlPath(url, currentDomain)\r\n    return [srcPath, currentDomain]\r\n}\r\n","export const retryTimesProp = 'retryTimes'\r\nexport const succeededProp = 'succeeded'\r\nexport const failedProp = 'failed'\r\nexport const maxRetryCountProp = 'maxRetryCount'\r\nexport const onRetryProp = 'onRetry'\r\nexport const onSuccessProp = 'onSuccess'\r\nexport const onFailProp = 'onFail'\r\nexport const domainProp = 'domain'\r\nexport const styleImageNoImportant = 'styleImageNoImportant'\r\nexport const innerProxyProp = '_assetsRetryProxy'\r\nexport const innerOnloadProp = '_assetsRetryOnload'\r\nexport const innerOnerrorProp = '_assetsRetryOnerror'\r\nexport const scriptTag = 'script'\r\nexport const linkTag = 'link'\r\nexport const hookedIdentifier = 'data-assets-retry-hooked'\r\nexport const ignoreIdentifier = 'data-assets-retry-ignore'\r\nexport const retryIdentifier = 'data-retry-id'\r\nexport const win = window\r\nexport const doc = window.document\r\nexport const ElementCtor = win.HTMLElement\r\nexport const ScriptElementCtor = win.HTMLScriptElement\r\nexport const StyleElementCtor = win.HTMLStyleElement\r\nexport const LinkElementCtor = win.HTMLLinkElement\r\nexport const ImageElementCtor = win.HTMLImageElement\r\n","import {\r\n    collectPropertyNames,\r\n    stringReplace,\r\n    isFunctionProperty,\r\n    loadNextScript,\r\n    safeCall,\r\n    hasOwn,\r\n    noop,\r\n    getTargetUrl,\r\n    loadNextLink,\r\n    unique,\r\n    isElementInCurrentContext\r\n} from './util'\r\n\r\nimport {\r\n    retryTimesProp,\r\n    maxRetryCountProp,\r\n    onRetryProp,\r\n    domainProp,\r\n    innerProxyProp,\r\n    innerOnloadProp,\r\n    innerOnerrorProp,\r\n    linkTag,\r\n    scriptTag,\r\n    hookedIdentifier,\r\n    ignoreIdentifier,\r\n    doc,\r\n    ScriptElementCtor,\r\n    LinkElementCtor,\r\n    win\r\n} from './constants'\r\nimport { retryCollector } from './collector'\r\nimport { prepareDomainMap, extractInfoFromUrl } from './url'\r\nimport { InnerAssetsRetryOptions } from './assets-retry'\r\n\r\ntype DynamicElement = HTMLScriptElement | HTMLLinkElement\r\n\r\nexport interface HookedElement {\r\n    [innerProxyProp]: DynamicElement\r\n    [innerOnerrorProp]: (e: Partial<Event>) => void\r\n    [x: string]: any\r\n}\r\n\r\n// cache all properties of HTMLScriptElement.prototype\r\n// (including prototype properties) because it's big (length > 200)\r\n// otherwise it would be calculated every time when\r\n// a script request failed.\r\nlet scriptAndLinkProperties: string[]\r\ntry {\r\n    scriptAndLinkProperties = unique([\r\n        ...collectPropertyNames(ScriptElementCtor.prototype),\r\n        ...collectPropertyNames(LinkElementCtor.prototype)\r\n    ])\r\n} catch (_) {\r\n    /* noop */\r\n}\r\n\r\n/**\r\n * create the descriptor of hooked element object,\r\n * accessing any property on the hooked element object\r\n * will be delegated to the real HTMLElement\r\n * except onload/onerror events\r\n *\r\n * @param {any} self hookedScript\r\n * @param {object} opts\r\n * @returns\r\n */\r\nconst getHookedElementDescriptors = function(self: HookedElement, opts: InnerAssetsRetryOptions) {\r\n    const maxRetryCount = opts[maxRetryCountProp]\r\n    const domainMap = prepareDomainMap(opts[domainProp])\r\n    const onRetry = opts[onRetryProp]\r\n    return scriptAndLinkProperties.reduce(function(descriptor, key) {\r\n        const isFn = isFunctionProperty(ScriptElementCtor.prototype, key)\r\n        // for function properties,\r\n        // do not assign getters/setters\r\n        if (isFn) {\r\n            descriptor[key] = {\r\n                value: function() {\r\n                    return (self[innerProxyProp] as any)[key].apply(self[innerProxyProp], arguments)\r\n                }\r\n            }\r\n        } else {\r\n            descriptor[key] = {\r\n                set: function(newVal) {\r\n                    const realElement = self[innerProxyProp]\r\n                    if (key === 'onerror') {\r\n                        self[innerOnerrorProp] = newVal\r\n                        // hook error events,\r\n                        // forward the original onerror handler\r\n                        // to the next script element to load\r\n                        realElement.onerror = function(event: Event | string) {\r\n                            if (typeof event === 'string') return\r\n                            event.stopPropagation && event.stopPropagation()\r\n                            const callOriginalOnError = () =>\r\n                                safeCall(self[innerOnerrorProp], realElement, event)\r\n                            const url = getTargetUrl(realElement)\r\n                            const [currentDomain, currentCollector] = extractInfoFromUrl(\r\n                                url,\r\n                                domainMap\r\n                            )\r\n                            const shouldIgnore = realElement.hasAttribute(ignoreIdentifier)\r\n                            if (!currentDomain || !currentCollector || shouldIgnore) {\r\n                                return callOriginalOnError()\r\n                            }\r\n                            if (!isElementInCurrentContext(event.target as Element)) {\r\n                                return callOriginalOnError()\r\n                            }\r\n                            const newSrc = stringReplace(\r\n                                url,\r\n                                currentDomain,\r\n                                domainMap[currentDomain]\r\n                            )\r\n                            const userModifiedSrc = onRetry(newSrc, url, currentCollector)\r\n                            // if onRetry returns null, do not retry this url\r\n                            if (userModifiedSrc === null) {\r\n                                return callOriginalOnError()\r\n                            }\r\n                            // eslint-disable-next-line\r\n                            if (typeof userModifiedSrc !== 'string') {\r\n                                throw new Error('a string should be returned in `onRetry` function')\r\n                            }\r\n                            if (currentCollector[retryTimesProp] <= maxRetryCount) {\r\n                                if (realElement instanceof ScriptElementCtor) {\r\n                                    loadNextScript(realElement, userModifiedSrc, noop, true)\r\n                                } else if (realElement instanceof LinkElementCtor) {\r\n                                    loadNextLink(realElement, userModifiedSrc)\r\n                                }\r\n                            } else {\r\n                                callOriginalOnError()\r\n                            }\r\n                        }\r\n                        return\r\n                    }\r\n                    if (key === 'onload') {\r\n                        self[innerOnloadProp] = newVal\r\n                        self[innerProxyProp].onload = function(event: Event) {\r\n                            if (newVal && !newVal._called) {\r\n                                newVal._called = true\r\n                                newVal.call(self[innerProxyProp], event)\r\n                            }\r\n                        }\r\n                        return\r\n                    }\r\n                    ;(realElement as any)[key] = newVal\r\n                },\r\n                get() {\r\n                    return (self[innerProxyProp] as any)[key]\r\n                }\r\n            }\r\n        }\r\n        return descriptor\r\n    }, {} as PropertyDescriptorMap)\r\n}\r\n\r\nconst createHookedElement = function(\r\n    $element: DynamicElement,\r\n    opts: InnerAssetsRetryOptions\r\n): HookedElement {\r\n    $element.setAttribute(hookedIdentifier, 'true')\r\n    const $hookedElement: HookedElement = {\r\n        [innerProxyProp]: $element,\r\n        [innerOnerrorProp]: noop\r\n    }\r\n    const descriptors = getHookedElementDescriptors($hookedElement, opts)\r\n    Object.defineProperties($hookedElement, descriptors)\r\n    $hookedElement.onload = noop\r\n    $hookedElement.onerror = noop\r\n    return $hookedElement\r\n}\r\n\r\n/**\r\n * hook `document.createElement`\r\n * @param {InnerAssetsRetryOptions} opts\r\n */\r\nconst hookCreateElement = function(opts: InnerAssetsRetryOptions) {\r\n    const originalCreateElement = doc.createElement\r\n    ;(doc as any).createElement = function(name: string, options: any): any {\r\n        if (name === scriptTag || name === linkTag) {\r\n            return createHookedElement((originalCreateElement as any).call(doc, name), opts)\r\n        }\r\n        if (name === 'iframe') {\r\n            const iframeElement = (originalCreateElement as any).call(doc, name) as HTMLIFrameElement\r\n            iframeElement.addEventListener('load', () => {\r\n                const window = iframeElement.contentWindow as any\r\n                if (window) {\r\n                    hookPrototypes(window)\r\n                }\r\n            });\r\n            return iframeElement\r\n        }\r\n        return originalCreateElement.call(doc, name, options)\r\n    }\r\n}\r\n\r\n/**\r\n * create a hooked function which hooks every method of target.\r\n * if a method is hooked and its arguments contains the inner script tag\r\n * it will be replaced with the value of inner script tag\r\n *\r\n * @param {any} target hook target\r\n */\r\nconst hookPrototype = function(target: any) {\r\n    const functionKeys = Object.keys(target).filter(key => isFunctionProperty(target, key))\r\n    functionKeys.forEach(key => {\r\n        const originalFunc = target[key]\r\n        target[key] = function(): any {\r\n            const args = [].slice.call(arguments).map((item: any) => {\r\n                if (!item) return item\r\n                return hasOwn.call(item, innerProxyProp) ? item[innerProxyProp] : item\r\n            })\r\n            return originalFunc.apply(this, args)\r\n        }\r\n    })\r\n}\r\n\r\nfunction hookPrototypes(window?: Window | null) {\r\n    try {\r\n        const realWindow: any = window || win\r\n        // eslint-disable-next-line\r\n        if (typeof realWindow.Node !== 'undefined') {\r\n            hookPrototype(realWindow.Node.prototype)\r\n        }\r\n        // eslint-disable-next-line\r\n        if (typeof realWindow.Element !== 'undefined') {\r\n            hookPrototype(realWindow.Element.prototype)\r\n        }\r\n    } catch (e) {\r\n        // ignore cross origin errors\r\n        if (window === win) {\r\n            throw e;\r\n        }\r\n    }\r\n}\r\n/**\r\n * init asynchronous retrying of script tags\r\n * @param {InnerAssetsRetryOptions} opts\r\n * @returns\r\n */\r\nexport default function initAsync(opts: InnerAssetsRetryOptions) {\r\n    hookCreateElement(opts)\r\n    hookPrototypes()\r\n    \r\n    return retryCollector\r\n}\r\n","/** @description data collector */\r\n\r\nimport { retryTimesProp, succeededProp, failedProp } from './constants'\r\n\r\nexport interface RetryCollector {\r\n    [x: string]: RetryStatistics\r\n}\r\n\r\nexport interface RetryStatistics {\r\n    [retryTimesProp]: number\r\n    [succeededProp]: string[]\r\n    [failedProp]: string[]\r\n}\r\n\r\n// statistic collector\r\nexport const retryCollector: RetryCollector = {}\r\n","import {\r\n    stringReplace,\r\n    loadNextScript,\r\n    loadNextLink,\r\n    hashTarget,\r\n    randomString,\r\n    arrayFrom,\r\n    getCssRules,\r\n    getTargetUrl\r\n} from './util'\r\nimport { InnerAssetsRetryOptions } from './assets-retry'\r\nimport { extractInfoFromUrl, splitUrl } from './url'\r\nimport {\r\n    retryTimesProp,\r\n    failedProp,\r\n    hookedIdentifier,\r\n    succeededProp,\r\n    doc,\r\n    retryIdentifier,\r\n    onRetryProp,\r\n    onSuccessProp,\r\n    onFailProp,\r\n    domainProp,\r\n    maxRetryCountProp,\r\n    ScriptElementCtor,\r\n    LinkElementCtor,\r\n    ImageElementCtor,\r\n    ignoreIdentifier\r\n} from './constants'\r\n\r\nconst retryCache: { [x: string]: boolean } = {}\r\n\r\n/**\r\n * init synchronous retrying of assets,\r\n * this includes the retrying of\r\n * script, link and img tags\r\n *\r\n * @export\r\n * @param {InnerAssetsRetryOptions} opts\r\n */\r\nexport default function initSync(opts: InnerAssetsRetryOptions) {\r\n    const onRetry = opts[onRetryProp]\r\n    const onSuccess = opts[onSuccessProp]\r\n    const onFail = opts[onFailProp]\r\n    const domainMap = opts[domainProp]\r\n    /**\r\n     * capture error on window\r\n     * when js / css / image failed to load\r\n     * reload the target with new domain\r\n     *\r\n     * @param {ErrorEvent} event\r\n     * @returns\r\n     */\r\n    const errorHandler = function(event: Event) {\r\n        if (!event) {\r\n            return\r\n        }\r\n        const target = event.target || event.srcElement\r\n        const originalUrl = getTargetUrl(target)\r\n        if (!originalUrl) {\r\n            // not one of script / link / image element\r\n            return\r\n        }\r\n        const [currentDomain, currentCollector] = extractInfoFromUrl(originalUrl, domainMap)\r\n        const hasIgnoreIdentifier =\r\n            target instanceof HTMLElement && target.hasAttribute(ignoreIdentifier)\r\n        if (!currentCollector || !currentDomain || hasIgnoreIdentifier) {\r\n            return\r\n        }\r\n        if (target instanceof LinkElementCtor && target.getAttribute('rel') !== 'stylesheet') {\r\n            return\r\n        }\r\n        currentCollector[retryTimesProp]++\r\n        currentCollector[failedProp].push(originalUrl)\r\n        const isFinalRetry = currentCollector[retryTimesProp] > opts[maxRetryCountProp]\r\n        if (isFinalRetry) {\r\n            const [srcPath] = splitUrl(originalUrl, domainMap)\r\n            onFail(srcPath)\r\n        }\r\n        if (!domainMap[currentDomain] || isFinalRetry) {\r\n            // can not find a domain to switch\r\n            // or failed too many times\r\n            return\r\n        }\r\n        const newDomain = domainMap[currentDomain]\r\n        const newUrl = stringReplace(originalUrl, currentDomain, newDomain)\r\n        const userModifiedUrl = onRetry(newUrl, originalUrl, currentCollector)\r\n        // if onRetry returns null, do not retry this url\r\n        if (userModifiedUrl === null) {\r\n            return\r\n        }\r\n        // eslint-disable-next-line\r\n        if (typeof userModifiedUrl !== 'string') {\r\n            throw new Error('a string should be returned in `onRetry` function')\r\n        }\r\n        if (target instanceof ImageElementCtor && target.src) {\r\n            target.setAttribute(retryIdentifier, randomString())\r\n            target.src = userModifiedUrl\r\n            return\r\n        }\r\n        // cache retried elements\r\n        const elementId = hashTarget(target)\r\n        if (retryCache[elementId]) {\r\n            return\r\n        }\r\n        retryCache[elementId] = true\r\n        if (\r\n            target instanceof ScriptElementCtor &&\r\n            !target.getAttribute(hookedIdentifier) &&\r\n            target.src\r\n        ) {\r\n            loadNextScript(target, userModifiedUrl)\r\n            return\r\n        }\r\n        if (\r\n            target instanceof LinkElementCtor &&\r\n            !target.getAttribute(hookedIdentifier) &&\r\n            target.href\r\n        ) {\r\n            loadNextLink(target, userModifiedUrl)\r\n            return\r\n        }\r\n    }\r\n\r\n    /**\r\n     * test is link element loaded in load event\r\n     *\r\n     * @param {Event} event\r\n     */\r\n    const loadHandler = function(event: Event) {\r\n        if (!event) {\r\n            return\r\n        }\r\n        const target = event.target || event.srcElement\r\n        const originalUrl = getTargetUrl(target)\r\n        if (!originalUrl) {\r\n            // not one of script / link / image element\r\n            return\r\n        }\r\n        const [_, currentCollector] = extractInfoFromUrl(originalUrl, domainMap)\r\n        const [srcPath] = splitUrl(originalUrl, domainMap)\r\n        const callOnSuccess = () => {\r\n            if (currentCollector) {\r\n                currentCollector[succeededProp].push(originalUrl)\r\n            }\r\n            onSuccess(srcPath)\r\n        }\r\n        // script / img tags succeeded to load without retry, add to collector\r\n        if (!(target instanceof LinkElementCtor)) {\r\n            callOnSuccess()\r\n            return\r\n        }\r\n        const supportStyleSheets = doc.styleSheets\r\n        // do not support styleSheets API\r\n        if (!supportStyleSheets) {\r\n            return\r\n        }\r\n        const styleSheets = arrayFrom(doc.styleSheets) as any[]\r\n        const targetStyleSheet = styleSheets.filter(styleSheet => {\r\n            return styleSheet.href === (target as any).href\r\n        })[0]\r\n        const rules = getCssRules(targetStyleSheet)\r\n        if (rules === null) {\r\n            return\r\n        }\r\n        // if the loaded stylesheet does not have rules, treat as failed\r\n        if (rules.length === 0) {\r\n            errorHandler(event)\r\n            return\r\n        }\r\n        callOnSuccess()\r\n    }\r\n\r\n    doc.addEventListener('error', errorHandler, true)\r\n    doc.addEventListener('load', loadHandler, true)\r\n}\r\n","let counter = Date.now() % 1e9;\r\nconst hasDefine = Object.defineProperty && (function() {\r\n  try {\r\n    // Avoid IE8's broken Object.defineProperty\r\n    return (Object.defineProperty({}, 'x', { value: 1 })).x === 1;\r\n  } catch (e) {\r\n    // no-op\r\n  }\r\n})();\r\n\r\n/**\r\n * WeakMap implementation\r\n */\r\nexport class WSet<K extends object> {\r\n  private _: string;\r\n  constructor() {\r\n    this._ = '__st' + (Math.random() * 1e9 >>> 0) + (counter++ + '__');\r\n  }\r\n  add(key: K) {\r\n    if (hasDefine) {\r\n      Object.defineProperty(key, this._, {\r\n        configurable: true,\r\n        writable: true,\r\n        value: true,\r\n      });\r\n    } else {\r\n      (key as any)[this._] = true;\r\n    }\r\n  }\r\n  has(key: K) {\r\n    return !!(key as any)[this._];\r\n  }\r\n  delete(key: K) {\r\n    if (!(key as any)[this._]) return false;\r\n    (key as any)[this._] = void 0;\r\n    return true;\r\n  }\r\n}","import { WSet } from './weak-set';\r\nimport { arrayFrom, stringReplace, toSlug, supportRules, getCssRules } from './util'\r\nimport { doc, domainProp, onRetryProp, StyleElementCtor } from './constants'\r\nimport { getCurrentDomain, DomainMap } from './url'\r\nimport { InnerAssetsRetryOptions } from './assets-retry'\r\n\r\ntype UrlProperty = 'backgroundImage' | 'borderImage' | 'listStyleImage'\r\n// cache for <link rel=\"stylesheet\" />\r\nconst handledStylesheets: { [x: string]: boolean } = {}\r\n// cache for <style />\r\nconst handledStyleTags = new WSet<HTMLStyleElement>();\r\n\r\nconst processRules = function(\r\n    name: UrlProperty,\r\n    rule: CSSStyleRule,\r\n    styleSheet: CSSStyleSheet,\r\n    styleRules: CSSRuleList,\r\n    opts: InnerAssetsRetryOptions\r\n) {\r\n    const domainMap = opts[domainProp]\r\n    const onRetry = opts[onRetryProp]\r\n    const targetRule = rule.style && rule.style[name]\r\n    if (!targetRule) {\r\n        return\r\n    }\r\n    // skip data-uri\r\n    if (/^url\\([\"']?data:/.test(targetRule)) {\r\n        return\r\n    }\r\n    const [_, originalUrl] = targetRule.match(/^url\\([\"']?(.+?)[\"']?\\)/) || []\r\n    if (!originalUrl) {\r\n        return\r\n    }\r\n    const currentDomain = getCurrentDomain(originalUrl, domainMap)\r\n    if (!currentDomain) {\r\n        return\r\n    }\r\n\r\n    let domain = currentDomain;\r\n    const urlMap: Record<string, boolean> = { [domain]: true };\r\n    while (domain && domainMap[domain]) {\r\n        const newDomain = domainMap[domain];\r\n        if (urlMap[newDomain]) {\r\n            break;\r\n        }\r\n        urlMap[newDomain] = true;\r\n        domain = newDomain;\r\n    }\r\n    const urlList = Object.keys(urlMap)\r\n        .map(domain => {\r\n            const newUrl = stringReplace(originalUrl, currentDomain, domain)\r\n            const userModifiedUrl = onRetry(newUrl, originalUrl, null)\r\n            return userModifiedUrl ? `url(\"${userModifiedUrl}\")` : null;\r\n        })\r\n        .filter(Boolean)\r\n        .join(',')\r\n    const cssText = rule.selectorText + `{ ${toSlug(name)}: ${urlList} ${opts.styleImageNoImportant ? '' : '!important'}; }`\r\n    try {\r\n        styleSheet.insertRule(cssText, styleRules.length)\r\n    } catch (_) {\r\n        styleSheet.insertRule(cssText, 0)\r\n    }\r\n}\r\n\r\nconst processStyleSheets = (styleSheets: CSSStyleSheet[], opts: InnerAssetsRetryOptions) => {\r\n    const urlProperties: UrlProperty[] = ['backgroundImage', 'borderImage', 'listStyleImage']\r\n    styleSheets.forEach((styleSheet: CSSStyleSheet) => {\r\n        const rules = getCssRules(styleSheet)\r\n        if (rules === null) {\r\n            return\r\n        }\r\n        const rulesLength = rules.length;\r\n        for (let i = 0; i < rulesLength; i++) {\r\n            const rule = rules[i] as CSSStyleRule;\r\n            urlProperties.forEach(cssProperty => {\r\n                processRules(cssProperty, rule, styleSheet, rules, opts)\r\n            })\r\n        }\r\n\r\n        if (styleSheet.href) {\r\n            handledStylesheets[styleSheet.href] = true\r\n        }\r\n        if (styleSheet.ownerNode instanceof StyleElementCtor) {\r\n            handledStyleTags.add(styleSheet.ownerNode);\r\n        }\r\n    })\r\n}\r\n\r\nconst getStyleSheetsToBeHandled = (styleSheets: StyleSheetList, domainMap: DomainMap): CSSStyleSheet[] => {\r\n    const sheetsArray = arrayFrom(styleSheets) as unknown as CSSStyleSheet[];\r\n    return sheetsArray.filter(styleSheet => {\r\n        if (!supportRules(styleSheet)) {\r\n            return false\r\n        }\r\n        // <style /> tags\r\n        if (!styleSheet.href) {\r\n            const ownerNode = styleSheet.ownerNode\r\n            if (ownerNode instanceof StyleElementCtor && handledStyleTags.has(ownerNode)) {\r\n                return false\r\n            }\r\n            return true\r\n        }\r\n        if (handledStylesheets[styleSheet.href]) {\r\n            return false\r\n        }\r\n        const currentDomain = getCurrentDomain(styleSheet.href, domainMap)\r\n        return !!currentDomain\r\n    })\r\n}\r\n\r\nexport default function initCss(opts: InnerAssetsRetryOptions) {\r\n    // detect is support styleSheets\r\n    const supportStyleSheets = doc.styleSheets\r\n    const domainMap = opts[domainProp]\r\n    if (!supportStyleSheets) return false\r\n    setInterval(() => {\r\n        const newStyleSheets = getStyleSheetsToBeHandled(doc.styleSheets, domainMap)\r\n        if (newStyleSheets.length > 0) {\r\n            processStyleSheets(newStyleSheets, opts)\r\n        }\r\n    }, 250)\r\n}\r\n","import initAsync from './retry-async'\r\nimport initSync from './retry-sync'\r\nimport initCss from './retry-css'\r\nimport { RetryStatistics, retryCollector } from './collector'\r\nimport {\r\n    maxRetryCountProp,\r\n    onRetryProp,\r\n    onSuccessProp,\r\n    onFailProp,\r\n    domainProp,\r\n    win,\r\n    styleImageNoImportant\r\n} from './constants'\r\nimport { Domain, DomainMap, prepareDomainMap } from './url'\r\nimport { identity, noop } from './util'\r\n\r\nexport type RetryFunction = (\r\n    currentUrl: string,\r\n    originalUrl: string,\r\n    retryCollector: null | RetryStatistics\r\n) => string | null\r\nexport type SuccessFunction = (currentPath: string) => void\r\nexport type FailFunction = (currentPath: string) => void\r\n\r\nexport interface AssetsRetryOptions {\r\n    [maxRetryCountProp]: number\r\n    [onRetryProp]?: RetryFunction\r\n    [onSuccessProp]?: SuccessFunction\r\n    [onFailProp]?: FailFunction\r\n    [domainProp]: Domain\r\n    [styleImageNoImportant]?: boolean\r\n}\r\n\r\nexport interface InnerAssetsRetryOptions {\r\n    [maxRetryCountProp]: number\r\n    [onRetryProp]: RetryFunction\r\n    [onSuccessProp]: SuccessFunction\r\n    [onFailProp]: FailFunction\r\n    [domainProp]: DomainMap\r\n    [styleImageNoImportant]: boolean\r\n}\r\n\r\nexport default function init(opts: AssetsRetryOptions = {} as any) {\r\n    try {\r\n        // eslint-disable-next-line\r\n        if (typeof opts[domainProp] !== 'object') {\r\n            throw new Error('opts.domain cannot be non-object.')\r\n        }\r\n        const optionList = [maxRetryCountProp, onRetryProp, onSuccessProp, onFailProp, domainProp, styleImageNoImportant]\r\n        const invalidOptions = Object.keys(opts).filter(key => optionList.indexOf(key) === -1)\r\n        if (invalidOptions.length > 0) {\r\n            throw new Error('option name: ' + invalidOptions.join(', ') + ' is not valid.')\r\n        }\r\n        const innerOpts: InnerAssetsRetryOptions = {\r\n            [maxRetryCountProp]: opts[maxRetryCountProp] || 3,\r\n            [onRetryProp]: opts[onRetryProp] || identity,\r\n            [onSuccessProp]: opts[onSuccessProp] || noop,\r\n            [onFailProp]: opts[onFailProp] || noop,\r\n            [domainProp]: prepareDomainMap(opts[domainProp]),\r\n            [styleImageNoImportant]: opts[styleImageNoImportant] || false\r\n        }\r\n        initAsync(innerOpts)\r\n        initSync(innerOpts)\r\n        if (__RETRY_IMAGE__) {\r\n            initCss(innerOpts)\r\n        }\r\n        return retryCollector\r\n    } catch (e) {\r\n        win.console && console.error('[assetsRetry] error captured', e)\r\n    }\r\n}\r\n"],"names":["identity","x","noop","collectPropertyNames","obj","getProto","Object","getPrototypeOf","__proto__","keys","concat","filter","key","isFunctionProperty","proto","e","prepareDomainMap","domains","Array","isArray","reduce","domainMap","domain","idx","array","length","getCurrentDomain","src","indexOf","sort","prev","next","scriptAndLinkProperties","map","retryTimesProp","succeededProp","failedProp","maxRetryCountProp","onRetryProp","onSuccessProp","onFailProp","domainProp","styleImageNoImportant","innerProxyProp","innerOnerrorProp","scriptTag","linkTag","hookedIdentifier","ignoreIdentifier","retryIdentifier","win","window","doc","document","ElementCtor","HTMLElement","ScriptElementCtor","HTMLScriptElement","StyleElementCtor","HTMLStyleElement","LinkElementCtor","HTMLLinkElement","ImageElementCtor","HTMLImageElement","hasOwn","prototype","hasOwnProperty","stringReplace","current","oldStr","newStr","substring","arrayFrom","arrayLike","slice","call","loadNextScript","$script","newSrc","onload","isAsync","$newScript","originalNonce","retryId","newHtml","newScript","isAsyncScript","defer","async","readyState","test","navigator","userAgent","createElement","forEach","_","onerror","setAttribute","randomString","getAttribute","getElementsByTagName","appendChild","outerHTML","replace","write","querySelector","getCssRules","styleSheet","rules","cssRules","loadNextLink","$link","newHref","$newLink","href","hashTarget","element","nodeName","join","Math","random","toString","getTargetUrl","target","retryCollector","extractInfoFromUrl","url","_b","splitUrl","srcPath","currentDomain","_a","substr","item","getHookedElementDescriptors","self","opts","maxRetryCount","onRetry","descriptor","isFn","value","apply","arguments","set","newVal","realElement","event","stopPropagation","callOriginalOnError","func","thisArg","args","currentCollector","shouldIgnore","hasAttribute","parent","parentNode","isElementInCurrentContext","userModifiedSrc","Error","_called","get","hookCreateElement","originalCreateElement","name","options","$element","$hookedElement","descriptors","defineProperties","createHookedElement","iframeElement_1","addEventListener","contentWindow","hookPrototypes","hookPrototype","originalFunc","this","realWindow","Node","Element","retryCache","initSync","errorHandler","srcElement","originalUrl","hasIgnoreIdentifier","push","isFinalRetry","onFail","newDomain","newUrl","userModifiedUrl","elementId","onSuccess","callOnSuccess","targetStyleSheet","styleSheets","counter","Date","now","hasDefine","defineProperty","WSet","configurable","writable","processRules","rule","styleRules","targetRule","style","match","urlMap","urlList","Boolean","cssText","selectorText","$1","$2","toLowerCase","insertRule","handledStylesheets","handledStyleTags","processStyleSheets","urlProperties","rulesLength","i","cssProperty","ownerNode","add","getStyleSheetsToBeHandled","has","supportStyleSheets","optionList_1","invalidOptions","innerOpts","setInterval","newStyleSheets","console","error"],"mappings":"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"}