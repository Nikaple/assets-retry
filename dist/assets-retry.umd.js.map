{"version":3,"file":"assets-retry.umd.js","sources":["../src/util.ts","../src/url.ts","../src/constants.ts","../src/collector.ts","../src/retry-async.ts","../src/retry-sync.ts","../src/assets-retry.ts"],"sourcesContent":["import { scriptTag, linkTag, doc, retryIdentifier } from './constants'\n\nexport const identity = function<T>(x: T): T {\n    return x\n}\nexport const noop = () => {\n    /* noop */\n}\n\nexport const hasOwn = Object.prototype.hasOwnProperty\n/**\n * safely calls a function\n *\n * @template T this\n * @template R ReturnType<func>\n * @param {(this: T, ...callbackArgs: any[]) => R} func\n * @param {T} thisArg\n * @param {*} args\n * @returns {R}\n */\nexport const safeCall = function<T, R>(\n    func: (this: T, ...callbackArgs: any[]) => R,\n    thisArg: T,\n    args: any\n): R {\n    if (typeof func !== 'function') {\n        return null as any\n    }\n    return func.call(thisArg, args)\n}\n\n/**\n * replace a substring with new one\n *\n * @param {string} current current string\n * @param {string} oldStr substring to replace\n * @param {string} newStr new string\n * @returns\n */\nexport const stringReplace = function(current: string, oldStr: string, newStr: string) {\n    const idx = current.indexOf(oldStr)\n    return current.substring(0, idx) + newStr + current.substring(idx + oldStr.length)\n}\n\n/**\n * convert a camelCase string to a dash-separated string.\n *\n * @param {string} str\n * @returns\n */\nexport const toSlug = function(str: string) {\n    return str.replace(/([a-z])([A-Z])/g, (_, $1, $2) => `${$1}-${$2.toLowerCase()}`)\n}\n\n/**\n * set default value for object\n *\n * @param {any} obj object\n * @param {string} key key\n * @param {any} defaultValue default value\n */\nexport const setDefault = function(obj: any, key: string, defaultValue: any) {\n    obj[key] = obj[key] || defaultValue\n}\n\n/**\n * transform an array-like object to array\n *\n * @template T\n * @param {ArrayLike<T>} arrayLike\n * @returns {T[]}\n */\nexport const arrayFrom = function<T>(arrayLike: ArrayLike<T>): T[] {\n    return [].slice.call(arrayLike)\n}\n/**\n * collect all property names from current object to its ancestor\n *\n * @param {any} obj\n * @returns\n */\nexport const collectPropertyNames = function(obj: any) {\n    const getProto = Object.getPrototypeOf\n        ? Object.getPrototypeOf\n        : function(x: any) {\n              return x.__proto__\n          }\n    let keys = Object.keys(obj)\n    while (getProto(obj)) {\n        keys = keys.concat(Object.keys(getProto(obj)))\n        obj = getProto(obj)\n    }\n    return keys\n}\n\n/**\n * @example\n * isFunctionProperty(HTMLScriptElement.prototype, 'src); // false\n * isFunctionProperty(HTMLScriptElement.prototype, 'getAttribute'); // true\n * @param {any} proto\n * @param {string} key\n * @returns\n */\nexport const isFunctionProperty = function(proto: any, key: string) {\n    try {\n        return typeof proto[key] === 'function'\n    } catch (e) {\n        // TypeError: Illegal invocation\n        // when evaluating properties like\n        // HTMLScriptElement.prototype.src\n        return false\n    }\n}\n\n/**\n * loads a new script element by previous failed script element\n *\n * @param {HTMLScriptElement} $script previous script element\n * @param {string} newSrc new url to try\n */\nexport const loadNextScript = function(\n    $script: HTMLScriptElement,\n    newSrc: string,\n    onload: () => void = noop\n) {\n    // when dealing with failed script tags in html,\n    // use `document.write` to ensure the correctness\n    // of loading order\n    if (document.readyState === 'loading') {\n        console.log('[document.write]', newSrc)\n        const retryId = Math.random()\n            .toString(36)\n            .slice(2)\n        const newHtml = $script.outerHTML\n            // delete previous retry id\n            .replace(/data-retry-id=\"[^\"]+\"/, '')\n            .replace(/src=(?:\"[^\"]+\"|.+)([ >])/, `${retryIdentifier}=${retryId} src=\"${newSrc}\"$1`)\n        document.write(newHtml)\n        const newScript = document.querySelector(\n            `script[${retryIdentifier}=\"${retryId}\"]`\n        ) as HTMLScriptElement\n        if (newScript) {\n            newScript.onload = onload\n        }\n        return\n    }\n    const $newScript = doc.createElement(scriptTag)\n    console.log('[document.createElement]', newSrc)\n    // copy script properties except src:\n    // type, noModule, charset, async, defer,\n    // crossOrigin, text, referrerPolicy, event,\n    // htmlFor, integrity (chrome)\n    Object.keys(HTMLScriptElement.prototype).forEach(function(key: string) {\n        if (key !== 'src' && ($script as any)[key] && typeof ($script as any)[key] !== 'object') {\n            try {\n                ;($newScript as any)[key] = ($script as any)[key]\n            } catch (_) {\n                /* noop */\n            }\n        }\n    })\n    $newScript.src = newSrc\n    $newScript.onload = $script.onload\n    $newScript.onerror = $script.onerror\n    // webpack nonce for csp\n    const originalNonce = $script.getAttribute('nonce')\n    if (originalNonce) {\n        $newScript.setAttribute('nonce', originalNonce)\n    }\n    doc.getElementsByTagName('head')[0].appendChild($newScript)\n}\n\n/**\n * loads a new link element by previous failed link element\n *\n * @param {HTMLLinkElement} $link previous link element\n * @param {string} newHref new url to try\n */\nexport const loadNextLink = function($link: HTMLLinkElement, newHref: string, onload: () => void) {\n    const $newLink = doc.createElement(linkTag)\n    // copy link properties except href:\n    // disabled, href, crossOrigin, rel, relList, media, hreflang,\n    // type, as, referrerPolicy, sizes, imageSrcset, imageSizes,\n    // charset, rev, target, sheet, integrity, import (chrome)\n    Object.keys(HTMLLinkElement.prototype).forEach(function(key: string) {\n        if (key !== 'href' && ($link as any)[key] && typeof ($link as any)[key] !== 'object') {\n            try {\n                ;($newLink as any)[key] = ($link as any)[key]\n            } catch (_) {\n                /* noop */\n            }\n        }\n    })\n    $newLink.href = newHref\n    $newLink.onload = onload\n    doc.getElementsByTagName('head')[0].appendChild($newLink)\n}\n","import { retryCollector, RetryStatistics } from './collector'\nimport { retryTimesProp, failedProp, succeededProp } from './constants'\n\nexport type Domain = string[] | { [x: string]: string }\nexport interface DomainMap {\n    [x: string]: string\n}\n\n/**\n * generate the domain map from user\n * @example\n * generateDomainMap(['a.cdn', 'b.cdn', 'c.cdn']) // {'a.cdn': 'b.cdn', 'b.cdn': 'c.cdn', 'c.cdn': 'a.cdn'}\n *\n * @param {Domain} domains\n * @returns {DomainMap}\n */\nexport const prepareDomainMap = function(domains: Domain): DomainMap {\n    // array\n    if (Array.isArray(domains)) {\n        return domains.reduce(function(domainMap, domain, idx, array) {\n            domainMap[domain] = array[(idx + 1) % array.length]\n            return domainMap\n        }, {} as DomainMap)\n    }\n    // object\n    return domains\n}\n\n/**\n * get path from src\n * @example\n * getUrlPath('https://a.cdn/js/1.js', 'a.cdn'); // '/js/1.js'\n * getUrlPath('https://a.cdn/namespace/js/1.js', 'a.cdn/namespace'); // '/js/1.js'\n * @param {string} src script src\n * @param {string} currentDomain domain name\n * @returns {string}\n */\nexport const getUrlPath = function(src: string, currentDomain: string) {\n    return src.substr(src.indexOf(currentDomain) + currentDomain.length, src.length)\n}\n\n/**\n * find out the domain of current loading script\n *\n * @param {string} src\n * @param {{ [x: string]: string }} domainMap\n * @returns\n */\nexport const getCurrentDomain = function(src: string, domainMap: DomainMap) {\n    return (\n        Object.keys(domainMap)\n            .filter(function(domain) {\n                return src.indexOf(domain) > -1\n            })\n            // sort by length (relevance)\n            .sort((prev, next) => next.length - prev.length)[0]\n    )\n}\n\n/**\n * extract domain from url, and get the\n * corresponding statistic collector\n * @param {string} url\n * @returns\n */\nexport const extractInfoFromUrl = function(\n    url: string,\n    domainMap: DomainMap\n): [string?, RetryStatistics?] {\n    const currentDomain = getCurrentDomain(url, domainMap)\n    if (!currentDomain) {\n        return []\n    }\n    const srcPath = getUrlPath(url, currentDomain)\n    retryCollector[srcPath] = retryCollector[srcPath] || {\n        [retryTimesProp]: 0,\n        [failedProp]: [],\n        [succeededProp]: []\n    }\n    return [currentDomain, retryCollector[srcPath]]\n}\n","export const retryTimesProp = 'retryTimes'\nexport const succeededProp = 'succeeded'\nexport const failedProp = 'failed'\nexport const maxRetryCountProp = 'maxRetryCount'\nexport const onRetryProp = 'onRetry'\nexport const domainProp = 'domain'\nexport const innerScriptProp = '_$assetsRetryScript'\nexport const innerOnloadProp = '_$assetsRetryOnload'\nexport const innerOnerrorProp = '_$assetsRetryOnerror'\nexport const scriptTag = 'script'\nexport const linkTag = 'link'\nexport const hookedIdentifier = 'data-assets-retry-hooked'\nexport const retryIdentifier = 'data-retry-id'\nexport const win = window\nexport const doc = window.document\n","/** @description data collector */\n\nimport { retryTimesProp, succeededProp, failedProp } from './constants'\n\nexport interface RetryCollector {\n    [x: string]: RetryStatistics\n}\n\nexport interface RetryStatistics {\n    [retryTimesProp]: number\n    [succeededProp]: string[]\n    [failedProp]: string[]\n}\n\n// statistic collector\nexport const retryCollector: RetryCollector = {}\n","import {\n    collectPropertyNames,\n    stringReplace,\n    isFunctionProperty,\n    loadNextScript,\n    safeCall,\n    hasOwn,\n    noop\n} from './util'\n\nimport {\n    retryTimesProp,\n    succeededProp,\n    failedProp,\n    maxRetryCountProp,\n    onRetryProp,\n    domainProp,\n    innerScriptProp,\n    innerOnloadProp,\n    innerOnerrorProp,\n    scriptTag,\n    hookedIdentifier,\n    doc,\n    win\n} from './constants'\nimport { retryCollector } from './collector'\nimport { prepareDomainMap, extractInfoFromUrl } from './url'\nimport { InnerAssetsRetryOptions } from './assets-retry'\nimport initCss from './retry-css'\n\nexport interface HookedScript {\n    [innerScriptProp]: HTMLScriptElement\n    [innerOnerrorProp]: (e: Partial<Event>) => void\n    [x: string]: any\n}\n\n// cache all properties of HTMLScriptElement.prototype\n// (including prototype properties) because it's big (length > 200)\n// otherwise it would be calculated every time when\n// a script request failed.\nconst scriptProperties = collectPropertyNames(HTMLScriptElement.prototype)\n\n/**\n * create the descriptor of hooked script object,\n * accessing any property on the hooked script object\n * will be delegated to the real HTMLScriptElement\n * except onload/onerror events\n *\n * @param {any} self hookedScript\n * @param {object} opts\n * @returns\n */\nconst getHookedScriptDescriptors = function(self: HookedScript, opts: InnerAssetsRetryOptions) {\n    const maxRetryCount = opts[maxRetryCountProp]\n    const domainMap = prepareDomainMap(opts[domainProp])\n    const onRetry = opts[onRetryProp]\n    return scriptProperties.reduce(function(descriptor, key) {\n        const isFn = isFunctionProperty(HTMLScriptElement.prototype, key)\n        // for function properties,\n        // do not assign getters/setters\n        if (isFn) {\n            descriptor[key] = {\n                value: function() {\n                    return (self[innerScriptProp] as any)[key].apply(\n                        self[innerScriptProp],\n                        arguments\n                    )\n                }\n            }\n        } else {\n            descriptor[key] = {\n                set: function(newVal) {\n                    if (key === 'onerror') {\n                        self[innerOnerrorProp] = newVal\n                        // hook error events,\n                        // forward the original onerror handler\n                        // to the next script element to load\n                        ;(self[innerScriptProp] as any).onerror = function(event: ErrorEvent) {\n                            event.stopPropagation && event.stopPropagation()\n                            const src = self[innerScriptProp].src\n                            const [currentDomain, currentCollector] = extractInfoFromUrl(\n                                src,\n                                domainMap\n                            )\n                            if (!currentDomain || !currentCollector) {\n                                return\n                            }\n                            const newSrc = stringReplace(\n                                src,\n                                currentDomain,\n                                domainMap[currentDomain]\n                            )\n                            const userModifiedSrc = onRetry(newSrc, src, currentCollector)\n                            // if onRetry returns null, do not retry this url\n                            if (userModifiedSrc === null) {\n                                return\n                            }\n                            if (typeof userModifiedSrc !== 'string') {\n                                throw new Error('a string should be returned in `onRetry` function')\n                            }\n                            if (currentCollector[retryTimesProp] < maxRetryCount) {\n                                loadNextScript(self[innerScriptProp], userModifiedSrc)\n                            } else {\n                                safeCall(self[innerOnerrorProp], self[innerScriptProp], event)\n                            }\n                        }\n                        return\n                    }\n                    if (key === 'onload') {\n                        self[innerOnloadProp] = newVal\n                        self[innerScriptProp].onload = function(event: Event) {\n                            const src = self[innerScriptProp].src\n                            const [_, currentCollector] = extractInfoFromUrl(src, domainMap)\n                            if (!currentCollector) {\n                                return\n                            }\n                            if (currentCollector[failedProp].indexOf(src) === -1) {\n                                currentCollector[succeededProp].push(src)\n                            }\n                            if (newVal && !newVal._called) {\n                                newVal._called = true\n                                newVal.call(self[innerScriptProp], event)\n                            }\n                        }\n                        return\n                    }\n                    ;(self[innerScriptProp] as any)[key] = newVal\n                },\n                get() {\n                    return (self[innerScriptProp] as any)[key]\n                }\n            }\n        }\n        return descriptor\n    }, {} as PropertyDescriptorMap)\n}\n\nconst createHookedScript = function(\n    $script: HTMLScriptElement,\n    opts: InnerAssetsRetryOptions\n): HookedScript {\n    $script.setAttribute(hookedIdentifier, 'true')\n    const $hookedScript: HookedScript = {\n        [innerScriptProp]: $script,\n        [innerOnerrorProp]: noop\n    }\n    const descriptors = getHookedScriptDescriptors($hookedScript, opts)\n    Object.defineProperties($hookedScript, descriptors)\n    return $hookedScript\n}\n\n/**\n * hook `document.createElement`\n * @param {InnerAssetsRetryOptions} opts\n */\nconst hookCreateElement = function(opts: InnerAssetsRetryOptions) {\n    const originalCreateElement = doc.createElement\n    ;(doc as any).createElement = function(name: string, options: any): any {\n        if (name === scriptTag) {\n            return createHookedScript((originalCreateElement as any).call(doc, scriptTag), opts)\n        }\n        return originalCreateElement.call(doc, name, options)\n    }\n    doc.createElement.toString = function() {\n        return 'function createElement() { [native code] }'\n    }\n}\n\n/**\n * create a hooked function which hooks every method of target.\n * if a method is hooked and its arguments contains the inner script tag\n * it will be replaced with the value of inner script tag\n *\n * @param {any} target hook target\n */\nconst hookPrototype = function(target: any, opts: InnerAssetsRetryOptions) {\n    const functionKeys = Object.keys(target).filter(key => isFunctionProperty(target, key))\n    functionKeys.forEach(key => {\n        const originalFunc = target[key]\n        target[key] = function(): any {\n            const args = [].slice.call(arguments).map((item: any) => {\n                return hasOwn.call(item, innerScriptProp) ? item[innerScriptProp] : item\n            })\n            if (__RETRY_IMAGE__) {\n                const isInsertOp =\n                    [\n                        'append',\n                        'appendChild',\n                        'insertBefore',\n                        'replaceChild',\n                        'insertAdjacentElement',\n                        'prepend'\n                    ].indexOf(key) > -1\n                if (isInsertOp && args[0] instanceof HTMLLinkElement) {\n                    args[0].addEventListener('load', () => {\n                        setTimeout(() => initCss(opts), 100)\n                    })\n                }\n            }\n            return originalFunc.apply(this, args)\n        }\n        // keep original toString\n        if (/^\\w+$/.test(key)) {\n            target[key].toString = new Function(`return 'function ${key}() { [native code] }'`)\n        }\n    })\n}\n/**\n * init asynchronous retrying of script tags\n * @param {InnerAssetsRetryOptions} opts\n * @returns\n */\nexport default function initAsync(opts: InnerAssetsRetryOptions) {\n    hookCreateElement(opts)\n    if (typeof Node !== 'undefined') {\n        hookPrototype(Node.prototype, opts)\n    }\n    if (typeof Element !== 'undefined') {\n        hookPrototype(Element.prototype, opts)\n    }\n    return retryCollector\n}\n","import { stringReplace, loadNextScript, loadNextLink } from './util'\nimport { InnerAssetsRetryOptions } from './assets-retry'\nimport { extractInfoFromUrl } from './url'\nimport {\n    retryTimesProp,\n    failedProp,\n    hookedIdentifier,\n    maxRetryCountProp,\n    succeededProp,\n    win,\n    doc\n} from './constants'\n\n/**\n * init synchronous retrying of assets,\n * this includes the retrying of\n * script, link and img tags\n *\n * @export\n * @param {InnerAssetsRetryOptions} opts\n */\nexport default function initSync(opts: InnerAssetsRetryOptions) {\n    const onRetry = opts.onRetry\n    const getTargetUrl = function(target: EventTarget | null) {\n        if (target instanceof HTMLScriptElement || target instanceof HTMLImageElement) {\n            return target.src\n        }\n        if (target instanceof HTMLLinkElement) {\n            return target.href\n        }\n        return null\n    }\n    /**\n     * capture error on window\n     * when js / css / image failed to load\n     * reload the target with new domain\n     *\n     * @param {ErrorEvent} event\n     * @returns\n     */\n    const errorHandler = function(event: ErrorEvent) {\n        if (!event) {\n            return\n        }\n        const target = event.target || event.srcElement\n        const domainMap = opts.domain\n        const originalUrl = getTargetUrl(target)\n        if (!originalUrl) {\n            // not one of script / link / image element\n            return\n        }\n        const [currentDomain, currentCollector] = extractInfoFromUrl(originalUrl, domainMap)\n        if (!currentCollector || !currentDomain) {\n            return\n        }\n        currentCollector[retryTimesProp]++\n        currentCollector[failedProp].push(originalUrl)\n        if (!domainMap[currentDomain] || currentCollector[retryTimesProp] > opts.maxRetryCount) {\n            // can not find a domain to switch\n            // or failed too many times\n            return\n        }\n        const newDomain = domainMap[currentDomain]\n        const newUrl = stringReplace(originalUrl, currentDomain, newDomain)\n        const userModifiedUrl = onRetry(newUrl, originalUrl, currentCollector)\n        // if onRetry returns null, do not retry this url\n        if (userModifiedUrl === null) {\n            return\n        }\n        if (typeof userModifiedUrl !== 'string') {\n            throw new Error('a string should be returned in `onRetry` function')\n        }\n        console.log('[document.onerror]', userModifiedUrl)\n        const onloadCallback = () => {\n            currentCollector[succeededProp].push(userModifiedUrl)\n        }\n        if (target instanceof HTMLScriptElement && !target.getAttribute(hookedIdentifier) && target.src) {\n            loadNextScript(target, userModifiedUrl, onloadCallback)\n            return\n        }\n        if (target instanceof HTMLLinkElement && target.href) {\n            loadNextLink(target, userModifiedUrl, onloadCallback)\n            return\n        }\n        if (target instanceof HTMLImageElement && target.src) {\n            target.src = userModifiedUrl\n            target.onload = onloadCallback\n        }\n    }\n\n    doc.addEventListener('error', errorHandler, true)\n}\n","import initAsync from './retry-async'\nimport initSync from './retry-sync'\nimport initCss from './retry-css'\nimport { RetryStatistics, retryCollector } from './collector'\nimport { maxRetryCountProp, onRetryProp, domainProp, win } from './constants'\nimport { Domain, DomainMap, prepareDomainMap } from './url'\nimport { setDefault, identity } from './util'\n\nexport type RetryFunction = (\n    currentUrl: string,\n    originalUrl: string,\n    retryCollector: null | RetryStatistics\n) => string | null\n\nexport interface AssetsRetryOptions {\n    [maxRetryCountProp]: number\n    [onRetryProp]: RetryFunction\n    [domainProp]: Domain\n}\n\nexport interface InnerAssetsRetryOptions {\n    [maxRetryCountProp]: number\n    [onRetryProp]: RetryFunction\n    [domainProp]: DomainMap\n}\n\nexport default function init(opts: AssetsRetryOptions = {} as any) {\n    try {\n        setDefault(opts, maxRetryCountProp, 3)\n        setDefault(opts, onRetryProp, identity)\n        if (typeof opts[domainProp] !== 'object') {\n            throw new Error('opts.domain cannot be non-object.')\n        }\n        const innerOpts: InnerAssetsRetryOptions = {\n            [maxRetryCountProp]: opts[maxRetryCountProp],\n            [onRetryProp]: opts[onRetryProp],\n            [domainProp]: prepareDomainMap(opts[domainProp])\n        }\n        initAsync(innerOpts)\n        initSync(innerOpts)\n        if (__RETRY_IMAGE__) {\n            initCss(innerOpts)\n        }\n        return retryCollector\n    } catch (e) {\n        console.error('[assetsRetry] error captured')\n    }\n}\n"],"names":["identity","x","noop","setDefault","obj","key","defaultValue","isFunctionProperty","proto","e","prepareDomainMap","domains","Array","isArray","reduce","domainMap","domain","idx","array","length","getCurrentDomain","src","Object","keys","filter","indexOf","sort","prev","next","retryTimesProp","succeededProp","failedProp","maxRetryCountProp","onRetryProp","domainProp","innerScriptProp","innerOnerrorProp","scriptTag","hookedIdentifier","retryIdentifier","doc","window","document","hasOwn","prototype","hasOwnProperty","stringReplace","current","oldStr","newStr","substring","loadNextScript","$script","newSrc","onload","readyState","$newScript","createElement","console","log","HTMLScriptElement","forEach","_","onerror","originalNonce","getAttribute","setAttribute","getElementsByTagName","appendChild","retryId","Math","random","toString","slice","newHtml","outerHTML","replace","write","newScript","querySelector","loadNextLink","$link","newHref","$newLink","HTMLLinkElement","href","retryCollector","extractInfoFromUrl","url","currentDomain","srcPath","substr","_a","getHookedScriptDescriptors","self","opts","maxRetryCount","onRetry","scriptProperties","descriptor","isFn","value","apply","arguments","set","newVal","event","stopPropagation","currentCollector","userModifiedSrc","Error","func","thisArg","args","call","push","_called","get","getProto","getPrototypeOf","__proto__","concat","collectPropertyNames","hookCreateElement","originalCreateElement","name","options","$hookedScript","descriptors","defineProperties","createHookedScript","hookPrototype","target","originalFunc","map","item","this","test","Function","initSync","addEventListener","srcElement","originalUrl","HTMLImageElement","newDomain","newUrl","userModifiedUrl","onloadCallback","innerOpts","Node","Element","error"],"mappings":"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"}